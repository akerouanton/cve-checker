package ubuntu

import (
    "io/ioutil"
    "os/exec"
    "os"
    "strings"
    "bufio"
    "path/filepath"
    "log"

    "github.com/NiR-/cve-checker/sources"
    "github.com/NiR-/cve-checker/cve"
    "github.com/NiR-/cve-checker/datastore"
    "errors"
    "fmt"
    "github.com/NiR-/cve-checker/distribution"
    "regexp"
)

type UbuntuSource struct {
    repoPath string
    vulns    []cve.CVE
}

func init() {
    /* tempDir, err := ioutil.TempDir("", "")
    if err != nil {
        return
    } */

    sources.RegisterSource("ubuntu", UbuntuSource{repoPath: "/tmp/ubuntu-cve-tracker"})
}

func (s UbuntuSource) Update(store datastore.Store, distro distribution.Distribution) (error) {
    // Check if the repository has already been clone by previous run
    _, err := os.Stat(s.repoPath)
    if err != nil && !os.IsNotExist(err) {
        return err
    }

    // In the case the repository does not exist, we fetch it
    // otherwise, we update the existing repo
    if err != nil {
        cmd := exec.Command("bzr", "checkout", "--lightweight", "lp:ubuntu-cve-tracker", s.repoPath)
        out, err := cmd.CombinedOutput()
        if err != nil {
            println("Command output", string(out))
            return  err
        }
    } else {
        cmd := exec.Command("bzr", "update")
        cmd.Dir = s.repoPath
        if err := cmd.Run(); err != nil {
            return err
        }
    }

    // Scan active/ and retired/ directory to fetch CVEs
    // and then store them
    for _, dir := range []string{"active", "retired"} {
        vulns, err := scanDir(filepath.Join(s.repoPath, dir), distro.Version)

        if err != nil {
            return err
        }

        store.StoreVulns(vulns...)
    }

    return nil
}

func scanDir(path string, distro string) (vulns []cve.CVE, err error) {
    activeDir, err := ioutil.ReadDir(path)
    if err != nil {
        return nil, err
    }

    for _, file := range activeDir {
        if !strings.HasPrefix(file.Name(), "CVE-") {
            continue
        }

        vuln, err := parseCVEFile(path, file.Name(), distro)
        if err != nil {
            log.Output(0, err.Error())
            continue
        }

        vulns = append(vulns, vuln)
    }

    return vulns, nil
}

func parseCVEFile(basepath string, filename string, distro string) (vuln cve.CVE, err error) {
    file, err := os.Open(filepath.Join(basepath, filename))
    if err != nil {
        return vuln, err
    }

    defer file.Close()

    vuln.Id = filename

    scanner := bufio.NewScanner(file)
    readingDescription := false

    packageStatusRegexp := regexp.MustCompile(fmt.Sprintf("%s_(?P<Name>[^:]*): (?P<Status>[^ ]+)(?: \\((?P<Version>[^ )]+)\\))?", distro))

    for scanner.Scan() {
        line := scanner.Text()

        if readingDescription && len(line) > 0 && line[0] != ' ' {
            readingDescription = false
        }
        if readingDescription {
            vuln.Description += " " + strings.TrimSpace(line)
            continue
        }

        if strings.HasPrefix(line, "Description:") {
            readingDescription = true
            continue
        }

        if strings.HasPrefix(line, "Priority:") {
            priority := strings.TrimSpace(strings.TrimPrefix(line, "Priority:"))
            if strings.Contains(priority, " ") {
                priority = strings.SplitN(priority, " ", 2)[0]
            }

            vuln.Severity, err = priorityToSeverity(priority)
            if err != nil {
                log.Output(0, err.Error())
            }

            continue
        }

        if packageStatusRegexp.MatchString(line) {
            matches := packageStatusRegexp.FindAllStringSubmatch(line, 10)
            affected := cve.AffectedPackage{
                Name: matches[0][1],
            }

            // Checking vulnerability status
            switch matches[0][2] {
            case "DNE",
                 "needs-triage",
                 "not-affected",
                 "ignored":
                continue
            case "pending",
                 "released":
                affected.PatchedVersion = matches[0][3]
            }

            vuln.AffectedPackages = append(vuln.AffectedPackages, affected)
        }
    }

    vuln.Description = strings.TrimSpace(vuln.Description)

    return vuln, nil
}

func priorityToSeverity(s string) (cve.Severity, error) {
    switch strings.ToLower(s) {
    case "untriaged":
        return cve.UnknownSeverity, nil
    case "negligible":
        return cve.NegligibleSeverity, nil
    case "low":
        return cve.LowSeverity, nil
    case "medium":
        return cve.MediumSeverity, nil
    case "high":
        return cve.HighSeverity, nil
    case "critical":
        return cve.CriticalSeverity, nil
    default:
        return cve.UnknownSeverity, errors.New(fmt.Sprintf("Failed to parse severity \"%s\".", s))
    }
}

func (s UbuntuSource) Cleanup() {
    os.RemoveAll(s.repoPath)
}
