package dpkg

import (
    "bufio"
    "os"
    "strings"
    "fmt"
    "regexp"
    "errors"
    "strconv"
    "unicode"
    "unicode/utf8"

    "github.com/NiR-/cve-checker/pkg"
    "github.com/NiR-/cve-checker/pkgmgr"
    "github.com/NiR-/cve-checker/distro"
)

var (
    epochUpstreamDebianRegexp = regexp.MustCompile("(\\d+):([\\d\\w.+-:~]+)-([\\d\\w.+~]+)")
    epochUpstreamRegexp       = regexp.MustCompile("(\\d+):([\\d\\w.+:~]+)")
    upstreamDebianRegexp      = regexp.MustCompile("([\\d\\w.+~-]+)-([\\d\\w.+~]+)")
    upstreamRegexp            = regexp.MustCompile("([\\d\\w.+~]+)")

    ErrFailedToNormalize = errors.New("failed to normalize version")
)

type NormalizedVersion struct {
    Epoch    uint64
    Upstream string
    Debian   string
}

type dpkg struct{}

func init() {
    pkgmgr.Register("dpkg", dpkg{})
}

func (d dpkg) InstalledPackages(distro distro.Distribution) (pkgs []pkg.Package, err error) {
    if distro.Name != "Ubuntu" && distro.Name != "Debian" {
        return nil, pkgmgr.ErrDistroNotSupported
    }

    file, err := os.Open("/var/lib/dpkg/status")
    if err != nil {
        return nil, err
    }

    defer file.Close()
    scanner := bufio.NewScanner(file)

    var pkgName, pkgVersion string
    pkgs = []pkg.Package{}

    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())

        if strings.HasPrefix(line, "Package:") {
            pkgName = strings.TrimSpace(strings.TrimPrefix(line, "Package:"))
            continue
        }

        if strings.HasPrefix(line, "Status:") {
            status := strings.TrimSpace(strings.TrimPrefix(line, "Status:"))

            if status != "install ok installed" {
                pkgName = ""
            }
        }

        if strings.HasPrefix(line, "Version:") {
            pkgVersion = strings.TrimSpace(strings.TrimPrefix(line, "Version:"))
        }

        if pkgName != "" && pkgVersion != "" {
            pkgs = append(pkgs, pkg.Package{
                Name:    pkgName,
                Version: pkgVersion,
                Pkgmgr:  "dpkg",
            })

            pkgName = ""
            pkgVersion = ""

            continue
        }

        if len(line) == 0 {
            if pkgName != "" && pkgVersion == "" {
                panic(fmt.Sprintf("No version found for package %s", pkgName))
            }
            pkgName = ""
            pkgVersion = ""
        }
    }

    return pkgs, nil
}

func (d dpkg) CompareVersion(left string, right string) (int8, error) {
    normalizedLeft, err := d.normalizeVersion(left)
    if err != nil {
        return 0, err
    }

    normalizedRight, err := d.normalizeVersion(right)
    if err != nil {
        return 0, err
    }

    if normalizedLeft.Epoch > normalizedRight.Epoch {
        return pkgmgr.LeftVersionIsNewer, nil
    }

    if normalizedLeft.Epoch < normalizedRight.Epoch {
        return pkgmgr.RightVersionIsNewer, nil
    }

    if res := compareStringFragment(normalizedLeft.Upstream, normalizedRight.Upstream); res != pkgmgr.VersionEqual {
        return res, nil
    }

    res := compareStringFragment(normalizedLeft.Debian, normalizedRight.Debian)
    return res, nil
}

// Compare two epoch or debian fragments together.
// It's merely based on the algorithm used by dpkg.
func compareStringFragment(left string, right string) int8 {
    maxlen := maxlen(left, right)

    for i := 0; i < maxlen; i++ {
        leftRune, _ := utf8.DecodeRuneInString(left)
        rightRune, _ := utf8.DecodeRuneInString(right)

        if leftRune != utf8.RuneError {
            left = left[1:]
        }
        if rightRune != utf8.RuneError {
            right = right[1:]
        }

        for leftRune != utf8.RuneError && !unicode.IsDigit(leftRune) ||
            (rightRune != utf8.RuneError && !unicode.IsDigit(rightRune)) {
            leftWeight := weightChar(leftRune)
            rightWeight := weightChar(rightRune)

            if leftWeight > rightWeight {
                return pkgmgr.LeftVersionIsNewer
            }

            if leftWeight < rightWeight {
                return pkgmgr.RightVersionIsNewer
            }

            leftRune, _ = utf8.DecodeRuneInString(left)
            rightRune, _ = utf8.DecodeRuneInString(right)

            if leftRune != utf8.RuneError {
                left = left[1:]
            }
            if rightRune != utf8.RuneError {
                right = right[1:]
            }
        }

        for leftRune == '0' {
            leftRune, _ = utf8.DecodeRuneInString(left)

            if leftRune != utf8.RuneError {
                left = left[1:]
            }
        }
        for rightRune == '0' {
            rightRune, _ = utf8.DecodeRuneInString(right)

            if rightRune != utf8.RuneError {
                right = right[1:]
            }
        }

        var firstDiff int8
        for unicode.IsDigit(leftRune) || unicode.IsDigit(rightRune) {
            if firstDiff == 0 {
                if leftRune == utf8.RuneError {
                    leftRune = 0
                }
                if rightRune == utf8.RuneError {
                    rightRune = 0
                }

                delta := int(leftRune) - 48 - (int(rightRune) - 48)

                if delta > 0 {
                    firstDiff = pkgmgr.LeftVersionIsNewer
                } else if delta == 0 {
                    firstDiff = pkgmgr.VersionEqual
                } else {
                    firstDiff = pkgmgr.RightVersionIsNewer
                }
            }

            leftRune, _ = utf8.DecodeRuneInString(left)
            rightRune, _ = utf8.DecodeRuneInString(right)

            if leftRune != utf8.RuneError {
                left = left[1:]
            }
            if rightRune != utf8.RuneError {
                right = right[1:]
            }
        }

        if unicode.IsDigit(leftRune) {
            return pkgmgr.LeftVersionIsNewer
        }
        if unicode.IsDigit(rightRune) {
            return pkgmgr.RightVersionIsNewer
        }
        if firstDiff != 0 {
            return firstDiff
        }
    }

    return pkgmgr.VersionEqual
}

func maxlen(x string, y string) int {
    xlen := len(x)
    ylen := len(y)

    if xlen > ylen || xlen == ylen {
        return xlen
    }

    return ylen
}

// Weight any char in upstream and debian version fragments.
// It's merely based on the algorithm used by dpkg.
func weightChar(char rune) int {
    if unicode.IsDigit(char) {
        return 0
    }

    if unicode.IsLetter(char) {
        return int(char)
    }

    if char == '~' {
        return -1
    }

    if char == utf8.RuneError {
        return 0
    }

    return 256 + int(char)
}

// Normalize debian versions.
// Debian versions have following formats: [epoch:]upstream[-debian]
// see: https://www.debian.org/doc/debian-policy/#version
func (d *dpkg) normalizeVersion(version string) (normalized NormalizedVersion, err error) {
    var matches []string

    if matches = epochUpstreamDebianRegexp.FindStringSubmatch(version); len(matches) == 4 {
        epoch, _ := strconv.ParseUint(matches[1], 10, 0)

        normalized = NormalizedVersion{
            Epoch:    epoch,
            Upstream: matches[2],
            Debian:   matches[3],
        }
    } else if matches = epochUpstreamRegexp.FindStringSubmatch(version); len(matches) == 3 {
        epoch, _ := strconv.ParseUint(matches[1], 10, 0)

        normalized = NormalizedVersion{
            Epoch:    epoch,
            Upstream: matches[2],
            Debian:   "0",
        }
    } else if matches = upstreamDebianRegexp.FindStringSubmatch(version); len(matches) == 3 {
        normalized = NormalizedVersion{
            Epoch:    0,
            Upstream: matches[1],
            Debian:   matches[2],
        }
    } else if matches = upstreamRegexp.FindStringSubmatch(version); len(matches) == 2 {
        normalized = NormalizedVersion{
            Epoch:    0,
            Upstream: matches[1],
            Debian:   "0",
        }
    } else {
        err = ErrFailedToNormalize
    }

    return normalized, err
}
